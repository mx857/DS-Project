├── books.hpp
│   #include <iostream>
│   #include <fstream>
│   #include <string>
│   #include "Tree.hpp"
│   #include <nlohmann/json.hpp>
│   using json=nlohmann::json;
│   using namespace std;
│   
│   class Books
│   {
│   private:
│       int book_id;
│       string title;
│       string author;
│       int total_copy;
│       int available_copy;
│   public:
│       Books(int book_id,string title,string author,int total_copy,int available_copy){
│           this->book_id=book_id;
│           this->title=title;
│           this->author=author;
│           this->total_copy=total_copy;
│           this->available_copy=available_copy;
│       };
│   
│       Books();
│   
│       bool operator<(const Books& b) const{
│           return this->book_id < b.book_id;
│       }
│   
│       void save_book(){
│           json books;
│           ifstream input("../database/Books.json");
│           if(input.is_open()){
│               input>>books;
│           }
│           else{
│               books=json::object();
│           }
│   
│           int newID=0;
│           for (auto& [key,value]:books.items())
│           {
│               newID=max(newID,stoi(key)+1);
│           }
│           json new_book;
│   
│           new_book[(to_string(newID))]={
│               {"Title",this->title},
│               {"Author",this->author},
│               {"Total",this->total_copy},
│               {"Available",this->available_copy}
│           };
│   
│           books[to_string(newID)]=new_book;
│           ofstream output("../database/Books.json");
│           output << books.dump(4);
│       }
│   
│       Tree<Books> load_book(){
│           Tree<Books> loaded_tree;
│           json book;
│           ifstream file("../database/Books.json");
│           if (!file.is_open()){
│               return loaded_tree;
│           }
│           file>>book;
│           for(auto& [key,value]:book.items()){
│               Books b;
│               b.book_id=stoi(key);
│               b.author=value["Author"];
│               b.available_copy=value["Available"];
│               b.title=value["Title"];
│               b.total_copy=value["Total"];
│   
│               loaded_tree.insert(b);
│           }
│           return loaded_tree;
│       }
│   
│       friend ostream& operator<<(ostream& os, const Books& b) {
│           os << "[ID: " << b.book_id
│              << ", Title: " << b.title
│              << ", Author: " << b.author
│              << ", Total: " << b.total_copy
│              << ", Available: " << b.available_copy
│              << " ]";
│           return os;
│       }
│       
│   };
├── LinkedList.hpp
│   #include <iostream>
│   #include "Node.hpp"
│   using namespace std;
│   
│   class LinkedList
│   {
│   private:
│       Node* head;
│   public:
│       LinkedList(){
│           head=nullptr;
│       }
│   
│       void insert_beginning(int value){
│           Node* newNode=new Node(value);
│           newNode->next=head;
│           head=newNode;
│       }
│   
│       void insert_end(int value){
│           Node* newNode=new Node(value);
│           if (head==nullptr){
│               head=newNode;
│               return;
│           }
│           Node* temp =head;
│           while (temp->next!=nullptr)
│           {
│               temp=temp->next;
│           }
│           temp->next=newNode;
│       }
│   
│       void inser_middle(int value,int position){
│           if(position==0){
│               insert_beginning(value);
│               return;
│           }
│           Node* newNode=new Node(value);
│           Node* temp=head;
│           for (int i = 0; temp != nullptr && i<position-1; i++)
│           {
│               temp=temp->next;
│           }
│           if (temp==nullptr){
│               cout<<"Position to insert is bigger than length of linked list"<<endl;
│               return;
│           }
│           newNode->next=temp->next;
│           temp->next=newNode;   
│       }
│    
│   
│       void delete_beginning(){
│           if (head==nullptr)
│           {
│               cout<<"Linked list is already empthy"<<endl;
│               return;
│           }
│           Node* temp=head;
│           head=head->next;
│           delete temp;
│           cout<<"Front Node is deleted"<<endl;
│       }
│   
│       void delete_end(){
│           if (head==nullptr)
│           {
│               cout<<"Linked list is already empthy"<<endl;
│               return;
│           }
│   
│           if(head->next==nullptr){
│               delete head;
│               head=nullptr;
│               cout<<"End Node is deleted"<<endl;
│           }
│   
│           Node* temp=head;
│           while (temp->next->next!=nullptr) 
│           {
│               temp=temp->next;
│           }
│           delete temp->next;
│           temp->next=nullptr;
│           cout<<"End Node is deleted"<<endl;
│       }
│   
│       void delete_middle(int value){
│           //delete by value
│           if (head==nullptr)
│           {
│               cout<<"Linked list is already empthy"<<endl;
│               return;
│           }
│   
│           if (head->data==value)
│           {
│               Node* temp=head;
│               head=head->next;
│               delete temp;
│               cout<<"Selected Node is deleted"<<endl;
│               return;
│           }
│           Node* temp=head;
│           while (temp->next->data!=value && temp->next!=nullptr)
│           {
│               temp=temp->next;
│           }
│   
│           if (temp->next==nullptr)
│           {
│               cout<<"No matching value found in linked list"<<endl;
│               return;
│           }
│   
│           Node* toDelete=temp->next;
│           temp->next=temp->next->next;
│           delete toDelete;
│           cout<<"Selected Node is deleted"<<endl;
│       }
│   
│       bool is_present(int value){
│           Node* temp=head;
│           while (temp->next!=nullptr)
│           {
│               if(temp->data==value){
│                   return true;
│               }
│               temp=temp->next;
│           }
│           return false;
│       }
│   
│       void display(){
│           Node* temp=head;
│           while (temp->next!=nullptr)
│           {
│               cout<<temp->data<<" -> " <<endl;
│               temp=temp->next;
│           }
│           cout<<"null"<<endl;
│       }
│       
│       int length(){
│           int length=0;
│           Node* temp=head;
│           while (temp->next!=nullptr)
│           {
│               length++;
│               temp=temp->next;
│           }
│           return length;
│       }
│   
│       void reverse(){
│           Node* previous=nullptr;
│           Node* current=head;
│           Node* next = nullptr;
│           while (current!=nullptr)
│           {
│               next=current->next;
│               current->next=previous;
│               previous=current;
│               current=next;
│           }
│           head=previous;
│       }
│   };├── Node.hpp
│   class Node
│   {
│   public:
│       int data;
│       Node* next;
│       Node(int value){
│           this->data=value;
│           this->next=nullptr;
│       }
│   };
├── queue.hpp
│   #include <iostream>
│   #include "Node.hpp"
│   using namespace std;
│   
│   
│   class Queue
│   {
│   private:
│       Node* front;
│       Node* rear;
│   public:
│       Queue(){
│           front=rear=nullptr;
│       };
│   
│       bool isEmpthy(){
│           return (front==nullptr);
│       }
│   
│       void enqueue(int value){
│           Node* temp=new Node(value);
│   
│           if (rear==nullptr)
│           {
│               front=rear=temp;
│               return;
│           }
│           rear->next=temp;
│           rear=temp;
│       }
│       void dequeue(){
│           if (isEmpthy())
│           {
│               cout<<"Queue is already empthy"<<endl;
│               return;
│           }
│           
│           
│       }
│   };
├── Stack.hpp
│   #include <iostream>
│   #include "Node.hpp"
│   
│   using namespace std;
│   
│   class Stack
│   {
│   private:
│       Node* top;
│   public:
│       Stack(){
│           top=nullptr;
│       }
│   
│       void push(int value){
│           Node* newNode=new Node(value);
│           newNode->next=top;
│           top=newNode;
│           cout<<value<<" pushed into stack"<<endl;
│       }
│   
│       void pop(){
│           if (top==nullptr)
│           {
│               cout<<"Stack is empthy"<<endl;
│               return;
│           }
│           Node* temp=top;
│           cout<<temp->data<<" poped from stack"<<endl;
│           top=top->next;
│           delete temp;
│       }
│   
│       int peak(){
│           if (top==nullptr)
│           {
│               cout<<"stack is empthy"<<endl;
│               return -1;
│           }
│           return top->data;
│       }
│   
│       bool isEmpthy(){
│           return top==nullptr;
│       }
│   
│       void display(){
│           if (top==nullptr)
│           {
│               cout<<"stack is empthy"<<endl;
│               return;
│           }
│           Node* temp=top;
│           cout<<"Stack : ";
│           while (temp!=nullptr)
│           {
│               cout<<temp->data<<" ";
│               temp=temp->next;
│           }
│           cout<<endl;   
│       }
│   };├── Tree.hpp
│   #include "Tree_node.hpp"
│   using namespace std;
│   
│   template <typename T>
│   class Tree 
│   {
│   private:
│       Node<T>* root;
│   public:
│       Tree(){
│           root=nullptr;
│        }
│   
│       
│       int getHeight(Node<T>* n){
│           if (n==nullptr) 
│           {
│               return 0;
│           }
│           return n->height;
│       }
│   
│       int getBalance(Node<T>* n){
│           if (n==nullptr) 
│           {
│               return 0;
│           }
│           return getHeight(n->left)-getHeight(n->right);
│       }
│   
│       Node<T>* rightR(Node<T>* y){
│           Node<T>* x = y->left;
│           Node<T>* T2 = x->right;
│   
│           x->right = y;
│           y->left = T2;
│   
│           y->height = max(getHeight(y->left), getHeight(y->right)) + 1;
│           x->height = max(getHeight(x->left), getHeight(x->right)) + 1;
│   
│           return x;
│       }
│   
│       Node<T>* leftR(Node<T>* x) {
│           Node<T>* y = x->right;
│           Node<T>* T2 = y->left;
│   
│           y->left = x;
│           x->right = T2;
│   
│           x->height = max(getHeight(x->left), getHeight(x->right)) + 1;
│           y->height = max(getHeight(y->left), getHeight(y->right)) + 1;
│   
│           return y;
│       }
│   
│       Node<T>* insert(Node<T>* node,const T& value){
│           if (node==nullptr)
│           {
│               return new Node<T>(value);
│           }
│           
│           if (value<node->data)
│           {
│               node->left=insert(node->left,value);
│           }
│           else if (value>node->data){
│               node->right=insert(node->right,value);
│           }
│           else{
│               return node;
│           }
│   
│           node->height=max(getHeight(node->left),getHeight(node->right));
│           int balance=getBalance(node);
│           
│           //LL
│           if (balance > 1 && value < node->left->data)
│               return rightR(node);
│   
│           //RR
│           if (balance < -1 && value > node->right->data)
│               return leftR(node);
│   
│           //LR
│           if (balance > 1 && value > node->left->data) {
│               node->left = leftR(node->left);
│               return rightR(node);
│           }
│   
│           //RL
│           if (balance < -1 && value < node->right->data) {
│               node->right = rightR(node->right);
│               return leftR(node);
│           }        
│       }
│   
│       void insert(const T& value){
│               root=insert(root,value);
│           }
│   
│       void inorder(Node<T>* node) {
│           if (node == nullptr){
│               return;
│           }
│           inorder(node->left);
│           cout << node->data <<" ";
│           inorder(node->right);
│       }
│       
│       void inorder() {
│           inorder(root);
│           cout<<endl;
│       }
│   };
├── Tree_node.hpp
│   template <typename T>
│   class Node 
│   {
│   public:
│       T data;
│       Node* left;
│       Node* right;
│   
│       int height;
│   
│       Node(const T& value){
│           data=value;
│           left=right=nullptr;
│           height=1; 
│       }
│   };└── ttt.txt
    ├── books.hpp
    │   #include <iostream>
    │   #include <fstream>
    │   #include <string>
    │   #include "Tree.hpp"
    │   #include <nlohmann/json.hpp>
    │   using json=nlohmann::json;
    │   using namespace std;
    │   
    │   class Books
    │   {
    │   private:
    │       int book_id;
    │       string title;
    │       string author;
    │       int total_copy;
    │       int available_copy;
    │   public:
    │       Books(int book_id,string title,string author,int total_copy,int available_copy){
    │           this->book_id=book_id;
    │           this->title=title;
    │           this->author=author;
    │           this->total_copy=total_copy;
    │           this->available_copy=available_copy;
    │       };
    │   
    │       Books();
    │   
    │       bool operator<(const Books& b) const{
    │           return this->book_id < b.book_id;
    │       }
    │   
    │       void save_book(){
    │           json books;
    │           ifstream input("../database/Books.json");
    │           if(input.is_open()){
    │               input>>books;
    │           }
    │           else{
    │               books=json::object();
    │           }
    │   
    │           int newID=0;
    │           for (auto& [key,value]:books.items())
    │           {
    │               newID=max(newID,stoi(key)+1);
    │           }
    │           json new_book;
    │   
    │           new_book[(to_string(newID))]={
    │               {"Title",this->title},
    │               {"Author",this->author},
    │               {"Total",this->total_copy},
    │               {"Available",this->available_copy}
    │           };
    │   
    │           books[to_string(newID)]=new_book;
    │           ofstream output("../database/Books.json");
    │           output << books.dump(4);
    │       }
    │   
    │       Tree<Books> load_book(){
    │           Tree<Books> loaded_tree;
    │           json book;
    │           ifstream file("../database/Books.json");
    │           if (!file.is_open()){
    │               return loaded_tree;
    │           }
    │           file>>book;
    │           for(auto& [key,value]:book.items()){
    │               Books b;
    │               b.book_id=stoi(key);
    │               b.author=value["Author"];
    │               b.available_copy=value["Available"];
    │               b.title=value["Title"];
    │               b.total_copy=value["Total"];
    │   
    │               loaded_tree.insert(b);
    │           }
    │           return loaded_tree;
    │       }
    │   
    │       friend ostream& operator<<(ostream& os, const Books& b) {
    │           os << "[ID: " << b.book_id
    │              << ", Title: " << b.title
    │              << ", Author: " << b.author
    │              << ", Total: " << b.total_copy
    │              << ", Available: " << b.available_copy
    │              << " ]";
    │           return os;
    │       }
    │       
    │   };
    ├── LinkedList.hpp
    │   #include <iostream>
    │   #include "Node.hpp"
    │   using namespace std;
    │   
    │   class LinkedList
    │   {
    │   private:
    │       Node* head;
    │   public:
    │       LinkedList(){
    │           head=nullptr;
    │       }
    │   
    │       void insert_beginning(int value){
    │           Node* newNode=new Node(value);
    │           newNode->next=head;
    │           head=newNode;
    │       }
    │   
    │       void insert_end(int value){
    │           Node* newNode=new Node(value);
    │           if (head==nullptr){
    │               head=newNode;
    │               return;
    │           }
    │           Node* temp =head;
    │           while (temp->next!=nullptr)
    │           {
    │               temp=temp->next;
    │           }
    │           temp->next=newNode;
    │       }
    │   
    │       void inser_middle(int value,int position){
    │           if(position==0){
    │               insert_beginning(value);
    │               return;
    │           }
    │           Node* newNode=new Node(value);
    │           Node* temp=head;
    │           for (int i = 0; temp != nullptr && i<position-1; i++)
    │           {
    │               temp=temp->next;
    │           }
    │           if (temp==nullptr){
    │               cout<<"Position to insert is bigger than length of linked list"<<endl;
    │               return;
    │           }
    │           newNode->next=temp->next;
    │           temp->next=newNode;   
    │       }
    │    
    │   
    │       void delete_beginning(){
    │           if (head==nullptr)
    │           {
    │               cout<<"Linked list is already empthy"<<endl;
    │               return;
    │           }
    │           Node* temp=head;
    │           head=head->next;
    │           delete temp;
    │           cout<<"Front Node is deleted"<<endl;
    │       }
    │   
    │       void delete_end(){
    │           if (head==nullptr)
    │           {
    │               cout<<"Linked list is already empthy"<<endl;
    │               return;
    │           }
    │   
    │           if(head->next==nullptr){
    │               delete head;
    │               head=nullptr;
    │               cout<<"End Node is deleted"<<endl;
    │           }
    │   
    │           Node* temp=head;
    │           while (temp->next->next!=nullptr) 
    │           {
    │               temp=temp->next;
    │           }
    │           delete temp->next;
    │           temp->next=nullptr;
    │           cout<<"End Node is deleted"<<endl;
    │       }
    │   
    │       void delete_middle(int value){
    │           //delete by value
    │           if (head==nullptr)
    │           {
    │               cout<<"Linked list is already empthy"<<endl;
    │               return;
    │           }
    │   
    │           if (head->data==value)
    │           {
    │               Node* temp=head;
    │               head=head->next;
    │               delete temp;
    │               cout<<"Selected Node is deleted"<<endl;
    │               return;
    │           }
    │           Node* temp=head;
    │           while (temp->next->data!=value && temp->next!=nullptr)
    │           {
    │               temp=temp->next;
    │           }
    │   
    │           if (temp->next==nullptr)
    │           {
    │               cout<<"No matching value found in linked list"<<endl;
    │               return;
    │           }
    │   
    │           Node* toDelete=temp->next;
    │           temp->next=temp->next->next;
    │           delete toDelete;
    │           cout<<"Selected Node is deleted"<<endl;
    │       }
    │   
    │       bool is_present(int value){
    │           Node* temp=head;
    │           while (temp->next!=nullptr)
    │           {
    │               if(temp->data==value){
    │                   return true;
    │               }
    │               temp=temp->next;
    │           }
    │           return false;
    │       }
    │   
    │       void display(){
    │           Node* temp=head;
    │           while (temp->next!=nullptr)
    │           {
    │               cout<<temp->data<<" -> " <<endl;
    │               temp=temp->next;
    │           }
    │           cout<<"null"<<endl;
    │       }
    │       
    │       int length(){
    │           int length=0;
    │           Node* temp=head;
    │           while (temp->next!=nullptr)
    │           {
    │               length++;
    │               temp=temp->next;
    │           }
    │           return length;
    │       }
    │   
    │       void reverse(){
    │           Node* previous=nullptr;
    │           Node* current=head;
    │           Node* next = nullptr;
    │           while (current!=nullptr)
    │           {
    │               next=current->next;
    │               current->next=previous;
    │               previous=current;
    │               current=next;
    │           }
    │           head=previous;
    │       }
    │   };├── Node.hpp
    │   class Node
    │   {
    │   public:
    │       int data;
    │       Node* next;
    │       Node(int value){
    │           this->data=value;
    │           this->next=nullptr;
    │       }
    │   };
    ├── queue.hpp
    │   #include <iostream>
    │   #include "Node.hpp"
    │   using namespace std;
    │   
    │   
    │   class Queue
    │   {
    │   private:
    │       Node* front;
    │       Node* rear;
    │   public:
    │       Queue(){
    │           front=rear=nullptr;
    │       };
    │   
    │       bool isEmpthy(){
    │           return (front==nullptr);
    │       }
    │   
    │       void enqueue(int value){
    │           Node* temp=new Node(value);
    │   
    │           if (rear==nullptr)
    │           {
    │               front=rear=temp;
    │               return;
    │           }
    │           rear->next=temp;
    │           rear=temp;
    │       }
    │       void dequeue(){
    │           if (isEmpthy())
    │           {
    │               cout<<"Queue is already empthy"<<endl;
    │               return;
    │           }
    │           
    │           
    │       }
    │   };
    ├── Stack.hpp
    │   #include <iostream>
    │   #include "Node.hpp"
    │   
    │   using namespace std;
    │   
    │   class Stack
    │   {
    │   private:
    │       Node* top;
    │   public:
    │       Stack(){
    │           top=nullptr;
    │       }
    │   
    │       void push(int value){
    │           Node* newNode=new Node(value);
    │           newNode->next=top;
    │           top=newNode;
    │           cout<<value<<" pushed into stack"<<endl;
    │       }
    │   
    │       void pop(){
    │           if (top==nullptr)
    │           {
    │               cout<<"Stack is empthy"<<endl;
    │               return;
    │           }
    │           Node* temp=top;
    │           cout<<temp->data<<" poped from stack"<<endl;
    │           top=top->next;
    │           delete temp;
    │       }
    │   
    │       int peak(){
    │           if (top==nullptr)
    │           {
    │               cout<<"stack is empthy"<<endl;
    │               return -1;
    │           }
    │           return top->data;
    │       }
    │   
    │       bool isEmpthy(){
    │           return top==nullptr;
    │       }
    │   
    │       void display(){
    │           if (top==nullptr)
    │           {
    │               cout<<"stack is empthy"<<endl;
    │               return;
    │           }
    │           Node* temp=top;
    │           cout<<"Stack : ";
    │           while (temp!=nullptr)
    │           {
    │               cout<<temp->data<<" ";
    │               temp=temp->next;
    │           }
    │           cout<<endl;   
    │       }
    │   };├── Tree.hpp
    │   #include "Tree_node.hpp"
    │   using namespace std;
    │   
    │   template <typename T>
    │   class Tree 
    │   {
    │   private:
    │       Node<T>* root;
    │   public:
    │       Tree(){
    │           root=nullptr;
    │        }
    │   
    │       
    │       int getHeight(Node<T>* n){
    │           if (n==nullptr) 
    │           {
    │               return 0;
    │           }
    │           return n->height;
    │       }
    │   
    │       int getBalance(Node<T>* n){
    │           if (n==nullptr) 
    │           {
    │               return 0;
    │           }
    │           return getHeight(n->left)-getHeight(n->right);
    │       }
    │   
    │       Node<T>* rightR(Node<T>* y){
    │           Node<T>* x = y->left;
    │           Node<T>* T2 = x->right;
    │   
    │           x->right = y;
    │           y->left = T2;
    │   
    │           y->height = max(getHeight(y->left), getHeight(y->right)) + 1;
    │           x->height = max(getHeight(x->left), getHeight(x->right)) + 1;
    │   
    │           return x;
    │       }
    │   
    │       Node<T>* leftR(Node<T>* x) {
    │           Node<T>* y = x->right;
    │           Node<T>* T2 = y->left;
    │   
    │           y->left = x;
    │           x->right = T2;
    │   
    │           x->height = max(getHeight(x->left), getHeight(x->right)) + 1;
    │           y->height = max(getHeight(y->left), getHeight(y->right)) + 1;
    │   
    │           return y;
    │       }
    │   
    │       Node<T>* insert(Node<T>* node,const T& value){
    │           if (node==nullptr)
    │           {
    │               return new Node<T>(value);
    │           }
    │           
    │           if (value<node->data)
    │           {
    │               node->left=insert(node->left,value);
    │           }
    │           else if (value>node->data){
    │               node->right=insert(node->right,value);
    │           }
    │           else{
    │               return node;
    │           }
    │   
    │           node->height=max(getHeight(node->left),getHeight(node->right));
    │           int balance=getBalance(node);
    │           
    │           //LL
    │           if (balance > 1 && value < node->left->data)
    │               return rightR(node);
    │   
    │           //RR
    │           if (balance < -1 && value > node->right->data)
    │               return leftR(node);
    │   
    │           //LR
    │           if (balance > 1 && value > node->left->data) {
    │               node->left = leftR(node->left);
    │               return rightR(node);
    │           }
    │   
    │           //RL
    │           if (balance < -1 && value < node->right->data) {
    │               node->right = rightR(node->right);
    │               return leftR(node);
    │           }        
    │       }
    │   
    │       void insert(const T& value){
    │               root=insert(root,value);
    │           }
    │   
    │       void inorder(Node<T>* node) {
    │           if (node == nullptr){
    │               return;
    │           }
    │           inorder(node->left);
    │           cout << node->data <<" ";
    │           inorder(node->right);
    │       }
    │       
    │       void inorder() {
    │           inorder(root);
    │           cout<<endl;
    │       }
    │   };
    ├── Tree_node.hpp
    │   template <typename T>
    │   class Node 
    │   {
    │   public:
    │       T data;
    │       Node* left;
    │       Node* right;
    │   
    │       int height;
    │   
    │       Node(const T& value){
    │           data=value;
    │           left=right=nullptr;
    │           height=1; 
    │       }
    │   };└── ttt.txt
